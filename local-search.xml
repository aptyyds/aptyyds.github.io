<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>字节开源的DeerFlow详解</title>
    <link href="/2025/09/03/%E5%AD%97%E8%8A%82%E5%BC%80%E6%BA%90%E7%9A%84DeerFlow%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/09/03/%E5%AD%97%E8%8A%82%E5%BC%80%E6%BA%90%E7%9A%84DeerFlow%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>DeerFlow 是一个基于多智能体系统的深度研究框架  ，主要在于多智能体之间的交互以及协调 。</p><p>用mermaid梳理下框架：</p><p><img src="/2025/09/03/%E5%AD%97%E8%8A%82%E5%BC%80%E6%BA%90%E7%9A%84DeerFlow%E8%AF%A6%E8%A7%A3/../../../image/%E5%AD%97%E8%8A%82%E5%BC%80%E6%BA%90%E7%9A%84DeerFlow%E8%AF%A6%E8%A7%A3/1756887800554.png" alt="1756887800554"></p><h2 id="技术架构特点"><a href="#技术架构特点" class="headerlink" title="技术架构特点"></a>技术架构特点</h2><h3 id="1-状态管理"><a href="#1-状态管理" class="headerlink" title="1. 状态管理"></a>1. 状态管理</h3><ul><li>基于 LangGraph 的状态机架构</li><li>消息传递系统</li><li>检查点保存和恢复</li><li>支持 MongoDB 和 PostgreSQL 持久化</li></ul><h3 id="2-Web-服务架构"><a href="#2-Web-服务架构" class="headerlink" title="2. Web 服务架构"></a>2. Web 服务架构</h3><ul><li>后端: FastAPI + Python</li><li>前端: Next.js + React</li><li>实时通信: Server-Sent Events (SSE)</li><li>容器化: Docker + Docker Compose</li></ul><h3 id="3-扩展性设计"><a href="#3-扩展性设计" class="headerlink" title="3. 扩展性设计"></a>3. 扩展性设计</h3><ul><li>模块化组件架构</li><li>插件式工具系统</li><li>配置驱动的行为定制</li><li>MCP 协议支持</li></ul><h3 id="4-多模态功能"><a href="#4-多模态功能" class="headerlink" title="4. 多模态功能"></a>4. 多模态功能</h3><ul><li>播客生成: AI 脚本编写 + 音频合成</li><li>PPT 生成: 自动化演示文稿创建</li><li>TTS 集成: 文本到语音转换</li><li>RAG 集成: 私有知识库支持</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li>用户输入 → 协调器接收并分类</li><li>任务识别 → 判断是否需要深度研究</li><li>背景调查 → (可选) 初步信息收集</li><li>计划制定 → 规划器创建结构化研究计划</li><li>人工反馈 → (可选) 人工审核和修改计划</li><li>执行研究 → 研究团队并行执行任务步骤</li><li>报告生成 → 聚合结果并生成最终报告</li></ol><p>一个多智能体协调系统 ，首先关注多智能体之间的通信，还有工作流是如何实现的 ，外部的工具调用 ，MCP是否使用 ，如何集成的？</p><p>多智能体之间的通信：</p><p>首先 ，这个项目用的是LangGraph作为核心通信基础设施 ，基于 LangGraph 的状态机模式，通过共享状态实现智能体间通信</p><p>MessagesState作为全局共享状态，通过这个状态进行通信 ，所有智能体可以读取和更新这个共享状态， 实现信息传递。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span>(<span class="hljs-title class_ inherited__">MessagesState</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;State for the agent system, extends MessagesState with next field.&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># Runtime Variables</span><br>    locale: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;en-US&quot;</span><br>    research_topic: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;&quot;</span><br>    observations: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>] = []<br>    resources: <span class="hljs-built_in">list</span>[Resource] = []<br>    plan_iterations: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>    current_plan: Plan | <span class="hljs-built_in">str</span> = <span class="hljs-literal">None</span><br>    final_report: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;&quot;</span><br>    auto_accepted_plan: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span><br>    enable_background_investigation: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">True</span><br>    background_investigation_results: <span class="hljs-built_in">str</span> = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>通常 ，</p><p>外部通信</p><p>MCP的集成</p><p>百度的框架</p><p>开源的，讲解</p><p>langchain的了解</p>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>魔改一个ChatBot以及技术分析</title>
    <link href="/2025/09/03/%E9%AD%94%E6%94%B9%E4%B8%80%E4%B8%AAChatBot%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/"/>
    <url>/2025/09/03/%E9%AD%94%E6%94%B9%E4%B8%80%E4%B8%AAChatBot%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="一、项目介绍"><a href="#一、项目介绍" class="headerlink" title="一、项目介绍"></a>一、项目介绍</h1><h1 id="二-、访问链接"><a href="#二-、访问链接" class="headerlink" title="二 、访问链接"></a>二 、访问链接</h1><p>部署上线的访问页面链接（需要VPN）（游客页面，无需登录）</p><p><a href="https://chatbox-nu-eosin.vercel.app/">ChatBot</a></p><p>登录页面（需VPN）</p><p><a href="https://chatbox-52e5mngls-kling-zeros-projects.vercel.app/">Login</a></p><h1 id="三-、功能支持"><a href="#三-、功能支持" class="headerlink" title="三 、功能支持"></a>三 、功能支持</h1><p>1、生成代码一键运行</p><p><img src="/2025/09/03/%E9%AD%94%E6%94%B9%E4%B8%80%E4%B8%AAChatBot%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/../../../image/%E9%AD%94%E6%94%B9%E4%B8%80%E4%B8%AAChatBot%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/1756880579993.png" alt="1756880579993"></p><p><img src="/2025/09/03/%E9%AD%94%E6%94%B9%E4%B8%80%E4%B8%AAChatBot%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/../../../image/%E9%AD%94%E6%94%B9%E4%B8%80%E4%B8%AAChatBot%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/1756880654108.png" alt="1756880654108"></p><p>2、白板式生成文章<br><img src="/2025/09/03/%E9%AD%94%E6%94%B9%E4%B8%80%E4%B8%AAChatBot%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/../../../image/%E9%AD%94%E6%94%B9%E4%B8%80%E4%B8%AAChatBot%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/1756880725209.png" alt="1756880725209"></p><p>3、天气查询</p><p>一键生成天气图片</p><p><img src="/2025/09/03/%E9%AD%94%E6%94%B9%E4%B8%80%E4%B8%AAChatBot%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/../../../image/%E9%AD%94%E6%94%B9%E4%B8%80%E4%B8%AAChatBot%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/1756880986757.png" alt="1756880986757"></p><h1 id="四、AI-Chatbot-项目后端技术栈与业务实现分析"><a href="#四、AI-Chatbot-项目后端技术栈与业务实现分析" class="headerlink" title="四、AI Chatbot 项目后端技术栈与业务实现分析"></a>四、AI Chatbot 项目后端技术栈与业务实现分析</h1><h2 id="后端技术栈"><a href="#后端技术栈" class="headerlink" title="后端技术栈"></a>后端技术栈</h2><h3 id="1-核心框架"><a href="#1-核心框架" class="headerlink" title="1. 核心框架"></a>1. <strong>核心框架</strong></h3><ul><li><strong>Next.js 15.3</strong> - 全栈 React 框架，支持 SSR 和 API Routes</li><li><strong>TypeScript</strong> - 类型安全的 JavaScript 超集</li><li><strong>Turbo</strong> - 高性能构建工具</li></ul><h3 id="2-数据库层"><a href="#2-数据库层" class="headerlink" title="2. 数据库层"></a>2. <strong>数据库层</strong></h3><ul><li><strong>PostgreSQL</strong> - 主数据库，使用 Vercel Postgres</li><li><strong>Drizzle ORM</strong> - 现代化的 TypeScript ORM<ul><li>类型安全的查询构建</li><li>自动迁移管理</li><li>支持关系查询</li></ul></li><li><strong>Redis</strong> - 缓存和流处理（可选）</li></ul><h3 id="3-身份认证系统"><a href="#3-身份认证系统" class="headerlink" title="3. 身份认证系统"></a>3. <strong>身份认证系统</strong></h3><ul><li><strong>NextAuth.js v5</strong> - 完整的身份认证解决方案</li><li><strong>bcrypt-ts</strong> - 密码哈希加密</li><li><strong>JWT</strong> - 无状态会话管理</li><li>支持两种用户类型：<ul><li><code>guest</code> - 访客用户（每日20条消息限制）</li><li><code>regular</code> - 注册用户（每日100条消息限制）</li></ul></li></ul><h3 id="4-AI-集成"><a href="#4-AI-集成" class="headerlink" title="4. AI 集成"></a>4. <strong>AI 集成</strong></h3><ul><li><strong>Vercel AI SDK</strong> - AI 应用开发框架</li><li><strong>xAI (Grok)</strong> - 主要 AI 模型提供商<ul><li><code>grok-2-vision-1212</code> - 通用聊天模型</li><li><code>grok-3-mini-beta</code> - 推理模型</li><li><code>grok-2-1212</code> - 标题生成和文档处理</li><li><code>grok-2-image</code> - 图像生成</li></ul></li></ul><h3 id="5-文件存储"><a href="#5-文件存储" class="headerlink" title="5. 文件存储"></a>5. <strong>文件存储</strong></h3><ul><li><strong>Vercel Blob</strong> - 文件上传和存储服务</li></ul><h3 id="6-监控与分析"><a href="#6-监控与分析" class="headerlink" title="6. 监控与分析"></a>6. <strong>监控与分析</strong></h3><ul><li><strong>OpenTelemetry</strong> - 可观测性框架</li><li><strong>Vercel Analytics</strong> - 性能分析</li></ul><h3 id="7-开发工具"><a href="#7-开发工具" class="headerlink" title="7. 开发工具"></a>7. <strong>开发工具</strong></h3><ul><li><strong>Biome</strong> - 代码格式化和 Linting</li><li><strong>Playwright</strong> - 端到端测试</li><li><strong>Drizzle Kit</strong> - 数据库迁移工具</li></ul><h2 id="数据库架构"><a href="#数据库架构" class="headerlink" title="数据库架构"></a>数据库架构</h2><h3 id="核心数据表："><a href="#核心数据表：" class="headerlink" title="核心数据表："></a>核心数据表：</h3><ol><li><p><strong>User</strong> - 用户表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">-</span> id: UUID (主键)<br><span class="hljs-operator">-</span> email: <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>)<br><span class="hljs-operator">-</span> password: <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>) (哈希加密)<br></code></pre></td></tr></table></figure></li><li><p><strong>Chat</strong> - 聊天会话表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">-</span> id: UUID (主键)<br><span class="hljs-operator">-</span> createdAt: <span class="hljs-type">TIMESTAMP</span><br><span class="hljs-operator">-</span> title: TEXT<br><span class="hljs-operator">-</span> userId: UUID (外键)<br><span class="hljs-operator">-</span> visibility: ENUM(<span class="hljs-string">&#x27;public&#x27;</span>, <span class="hljs-string">&#x27;private&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>Message_v2</strong> - 消息表（支持多部分消息）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">-</span> id: UUID (主键)<br><span class="hljs-operator">-</span> chatId: UUID (外键)<br><span class="hljs-operator">-</span> role: <span class="hljs-type">VARCHAR</span><br><span class="hljs-operator">-</span> parts: JSON (消息内容部分)<br><span class="hljs-operator">-</span> attachments: JSON (附件信息)<br><span class="hljs-operator">-</span> createdAt: <span class="hljs-type">TIMESTAMP</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Document</strong> - 文档表（Artifacts）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">-</span> id: UUID<br><span class="hljs-operator">-</span> createdAt: <span class="hljs-type">TIMESTAMP</span><br><span class="hljs-operator">-</span> title: TEXT<br><span class="hljs-operator">-</span> content: TEXT<br><span class="hljs-operator">-</span> kind: ENUM(<span class="hljs-string">&#x27;text&#x27;</span>, <span class="hljs-string">&#x27;code&#x27;</span>, <span class="hljs-string">&#x27;image&#x27;</span>, <span class="hljs-string">&#x27;sheet&#x27;</span>)<br><span class="hljs-operator">-</span> userId: UUID (外键)<br></code></pre></td></tr></table></figure></li><li><p><strong>Vote_v2</strong> - 消息评分表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">-</span> chatId: UUID (外键)<br><span class="hljs-operator">-</span> messageId: UUID (外键)<br><span class="hljs-operator">-</span> isUpvoted: <span class="hljs-type">BOOLEAN</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="业务实现流程"><a href="#业务实现流程" class="headerlink" title="业务实现流程"></a>业务实现流程</h2><h3 id="1-用户认证流程"><a href="#1-用户认证流程" class="headerlink" title="1. 用户认证流程"></a>1. <strong>用户认证流程</strong></h3><pre><code class=" mermaid">graph TD    A[用户访问] --&gt; B&#123;是否有Token?&#125;    B --&gt;|否| C[重定向到Guest登录]    C --&gt; D[创建Guest用户]    D --&gt; E[生成JWT Token]    B --&gt;|是| F[验证Token]    F --&gt; G[获取用户类型]    G --&gt; H[设置权限限制]</code></pre><h3 id="2-聊天消息处理流程"><a href="#2-聊天消息处理流程" class="headerlink" title="2. 聊天消息处理流程"></a>2. <strong>聊天消息处理流程</strong></h3><pre><code class=" mermaid">graph TD    A[接收聊天请求] --&gt; B[验证用户身份]    B --&gt; C[检查消息限制]    C --&gt; D&#123;是否超出限制?&#125;    D --&gt;|是| E[返回限制错误]    D --&gt;|否| F[保存用户消息]    F --&gt; G[初始化AI流处理]    G --&gt; H[调用AI模型]    H --&gt; I[处理工具调用]    I --&gt; J[流式返回响应]    J --&gt; K[保存AI响应]</code></pre><h3 id="3-Artifact-系统"><a href="#3-Artifact-系统" class="headerlink" title="3. Artifact 系统"></a>3. <strong>Artifact 系统</strong></h3><p>支持四种类型的文档生成：</p><ul><li><strong>Text</strong> - 文本文档</li><li><strong>Code</strong> - 代码文档</li><li><strong>Image</strong> - 图像生成</li><li><strong>Sheet</strong> - 表格数据</li></ul><p>每种类型都有专门的处理器：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">DocumentHandler</span> &#123;<br>  <span class="hljs-attr">kind</span>: <span class="hljs-title class_">ArtifactKind</span>;<br>  <span class="hljs-attr">onCreateDocument</span>: <span class="hljs-function">(<span class="hljs-params">args</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;<br>  <span class="hljs-attr">onUpdateDocument</span>: <span class="hljs-function">(<span class="hljs-params">args</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-流处理架构"><a href="#4-流处理架构" class="headerlink" title="4. 流处理架构"></a>4. <strong>流处理架构</strong></h3><ul><li>使用 <strong>Resumable Streams</strong> 实现可恢复的流处理</li><li>支持 Redis 缓存的流状态管理</li><li>实时数据传输通过 Server-Sent Events (SSE)</li></ul><h3 id="5-权限管理系统"><a href="#5-权限管理系统" class="headerlink" title="5. 权限管理系统"></a>5. <strong>权限管理系统</strong></h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> entitlements = &#123;<br>  <span class="hljs-attr">guest</span>: &#123;<br>    <span class="hljs-attr">maxMessagesPerDay</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">availableChatModelIds</span>: [<span class="hljs-string">&#x27;chat-model&#x27;</span>, <span class="hljs-string">&#x27;chat-model-reasoning&#x27;</span>]<br>  &#125;,<br>  <span class="hljs-attr">regular</span>: &#123;<br>    <span class="hljs-attr">maxMessagesPerDay</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-attr">availableChatModelIds</span>: [<span class="hljs-string">&#x27;chat-model&#x27;</span>, <span class="hljs-string">&#x27;chat-model-reasoning&#x27;</span>]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关键API端点"><a href="#关键API端点" class="headerlink" title="关键API端点"></a>关键API端点</h2><h3 id="聊天相关："><a href="#聊天相关：" class="headerlink" title="聊天相关："></a>聊天相关：</h3><ul><li><code>POST /api/chat</code> - 发送消息，处理AI响应</li><li><code>DELETE /api/chat</code> - 删除聊天会话</li><li><code>GET /api/history</code> - 获取聊天历史</li></ul><h3 id="文档相关："><a href="#文档相关：" class="headerlink" title="文档相关："></a>文档相关：</h3><ul><li><code>POST /api/document</code> - 创建&#x2F;更新文档</li><li><code>GET /api/document</code> - 获取文档内容</li></ul><h3 id="文件处理："><a href="#文件处理：" class="headerlink" title="文件处理："></a>文件处理：</h3><ul><li><code>POST /api/files/upload</code> - 文件上传</li></ul><h3 id="其他功能："><a href="#其他功能：" class="headerlink" title="其他功能："></a>其他功能：</h3><ul><li><code>POST /api/vote</code> - 消息评分</li><li><code>GET /api/suggestions</code> - 获取建议</li></ul><h1 id="五、个人处理"><a href="#五、个人处理" class="headerlink" title="五、个人处理"></a>五、个人处理</h1>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一个RAG系统的业务、框架以及技术实现</title>
    <link href="/2025/09/02/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AARAG%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%9A%E5%8A%A1%E3%80%81%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/09/02/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AARAG%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%9A%E5%8A%A1%E3%80%81%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>具体的业务流程</p><p><img src="/2025/09/02/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AARAG%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%9A%E5%8A%A1%E3%80%81%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/../../../image/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AARAG%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%9A%E5%8A%A1%E3%80%81%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/1756815491066.png" alt="1756815491066"></p><p>数据流架构图</p><p><img src="/2025/09/02/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AARAG%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%9A%E5%8A%A1%E3%80%81%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/../../../image/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AARAG%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%9A%E5%8A%A1%E3%80%81%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/1756815539249.png" alt="1756815539249"></p><p>代码层面</p><p><img src="/2025/09/02/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AARAG%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%9A%E5%8A%A1%E3%80%81%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/../../../image/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AARAG%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%9A%E5%8A%A1%E3%80%81%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/1756815626959.png" alt="1756815626959"></p><p>一个RAG系统 ，业务的复杂度更多的在于权限的控制 ，会话管理  ，文档的管理 ，而偏向于AI方面的 ，更多的是文本的分块处理 ，检索的策略 等。 </p><p>而一个后端开发人员，理解业务的复杂度的同时 ，也学会微调相关的参数  ，模型的相关调用 。</p>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从快递运输过程理解TCP协议</title>
    <link href="/2025/08/30/%E4%BB%8E%E5%BF%AB%E9%80%92%E8%BF%90%E8%BE%93%E8%BF%87%E7%A8%8B%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2025/08/30/%E4%BB%8E%E5%BF%AB%E9%80%92%E8%BF%90%E8%BE%93%E8%BF%87%E7%A8%8B%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p><img src="/2025/08/30/%E4%BB%8E%E5%BF%AB%E9%80%92%E8%BF%90%E8%BE%93%E8%BF%87%E7%A8%8B%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE/../../../image/%E4%BB%8E%E5%BF%AB%E9%80%92%E8%BF%90%E8%BE%93%E8%BF%87%E7%A8%8B%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE/1756517335807.png" alt="1756517335807"></p><p>首先， 从报文头部分析 ：</p><ul><li><p><strong>源端口号</strong> （Source Port）：16 位（2 个字节），用于标识发送端的应用程序。（快递寄件人）</p></li><li><p><strong>目标端口号</strong> （Destination Port）：也是 16 位，用于标识接收端的应用程序。（快递收件人）</p></li><li><p><strong>序列号</strong> （Sequence Number）：32 位，用于标识从 TCP 发送者发送的数据字节流中的第一个字节的顺序号。确保数据按顺序接收。（这是大包裹里分开的第几个包裹）</p></li><li><p><strong>确认号</strong> （Acknowledgment Number）：32 位，如果 ACK 标志被设置，则该字段包含发送确认的序列号，即接收 TCP 希望收到的下一个序列号。（告诉发送方 ，接收方希望收到的下一个包裹 ）</p></li><li><p><strong>数据偏移</strong> （Data Offset）：4 位，表示 TCP 报文头部的长度，用于指示数据开始的位置。（报文首部 长度 ，实际上相当于告诉收件人 ，应该把哪些没用包装丢掉 ，比如我包了5层快递袋子 ，拆掉这5层，才是我要给你的包裹）</p></li><li><p><strong>保留</strong> （Reserved）：6 位，为将来使用预留，目前必须置为 0。（快递面单的空白处， 以后留着升级用）</p></li><li><p><strong>控制位</strong> （Flags）：共 6 位，包括 URG（紧急指针字段是否有效）、ACK（确认字段是否有效）、PSH（提示接收端应该尽快将这个报文段交给应用层）、RST（重置连接）、SYN（同步序号，用于建立连接）、FIN（结束发送数据）。（标识快递 ，是否加急等 ，这个包裹处于什么状态）</p></li><li><p><strong>窗口大小</strong> （Window）：16 位，用于流量控制，表示接收端还能接收的数据的字节数（基于接收缓冲区的大小）。（收件人仓库还能放下多少）</p></li><li><p><strong>校验和</strong> （Checksum）：16 位，覆盖整个 TCP 报文段（包括 TCP 头部、数据和一个伪头部）的校验和，用于检测数据在传输过程中的任何变化。（快递容易防拆条 ，不见了或者坏了 ，说明包裹被动过，拒收或者丢弃）</p></li><li><p><strong>紧急指针</strong> （Urgent Pointer）：16 位，只有当 URG 控制位被设置时才有效，指出在报文段中有紧急数据的位置（包裹的状态标识是否有用）</p></li><li><p><strong>源端口号</strong> （快递寄件人）</p></li><li><p><strong>目标端口号</strong> （快递收件人）</p></li><li><p><strong>序列号</strong> （这是大包裹里分开的第几个包裹）</p></li><li><p><strong>确认号</strong> （告诉发送方 ，接收方希望收到的下一个包裹 ， 收货方告诉寄件人 ，下次希望收到哪个包裹 ）</p></li><li><p><strong>数据偏移</strong> （报文首部 长度 ，实际上相当于告诉收件人 ，应该把哪些没用包装丢掉 ，比如我包了5层快递袋子 ，拆掉这5层，才是我要给你的包裹）</p></li><li><p><strong>保留</strong> （Reserved）（快递面单的空白处， 以后留着升级用）</p></li><li><p><strong>控制位</strong> （Flags）（标识快递 ，是否加急等 ，这个包裹处于什么状态）</p></li><li><p><strong>窗口大小</strong> （Window）（收件人仓库还能放下多少）</p></li><li><p><strong>校验和</strong> （Checksum）（快递容易防拆条 ，不见了或者坏了 ，说明包裹被动过，拒收或者丢弃）</p></li><li><p><strong>紧急指针</strong> （Urgent Pointer）（包裹的状态标识是否有用）</p></li></ul><p>接下来理解流量控制 ，拥塞控制</p><p>流量控制针对寄件人和收件人 ，取决于收件人仓库的大小</p><p>详细的流量控制：</p><p>TCP 滑动窗口分为两种: 发送窗口和接收窗口。<strong>发送端的滑动窗口</strong>包含四大部分，如下：</p><ul><li>已发送且已收到 ACK 确认</li><li>已发送但未收到 ACK 确认</li><li>未发送但可以发送</li><li>未发送也不可以发送</li></ul><p><img src="/2025/08/30/%E4%BB%8E%E5%BF%AB%E9%80%92%E8%BF%90%E8%BE%93%E8%BF%87%E7%A8%8B%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE/../../../image/%E4%BB%8E%E5%BF%AB%E9%80%92%E8%BF%90%E8%BE%93%E8%BF%87%E7%A8%8B%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE/1756518795882.png" alt="1756518795882"><br>发送端滑动窗口</p><ul><li>深蓝色框里就是发送窗口。</li><li>SND.WND: 表示发送窗口的大小, 上图虚线框的格子数是 10 个，即发送窗口大小是 10。</li><li>SND.NXT：下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号。</li><li>SND.UNA: 一个绝对指针，它指向的是已发送但未确认的第一个字节的序列号。</li></ul><p>接收方的滑动窗口包含三大部分，如下：</p><ul><li>已成功接收并确认</li><li>未收到数据但可以接收</li><li>未收到数据并不可以接收的数据</li></ul><p><img src="/2025/08/30/%E4%BB%8E%E5%BF%AB%E9%80%92%E8%BF%90%E8%BE%93%E8%BF%87%E7%A8%8B%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE/../../../image/%E4%BB%8E%E5%BF%AB%E9%80%92%E8%BF%90%E8%BE%93%E8%BF%87%E7%A8%8B%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE/1756518826202.png" alt="1756518826202"><br>接收方滑动窗口</p><ul><li>蓝色框内，就是接收窗口。</li><li>REV.WND: 表示接收窗口的大小, 上图虚线框的格子就是 9 个。</li><li>REV.NXT: 下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号</li></ul><p>拥塞控制是针对整个链路， 比如双十一的快递网络 ，整个网络上快递太多了 ，就堵住了</p><p>拥塞窗口cwnd  </p><p>使用方法：慢启动 ，拥塞避免 ，拥塞发生， 快速恢复</p><p>再理解粘包和拆包，快递小了打包发货 ，大了拆成小件发</p><p>重传机制：重传包括 <strong>超时重传、快速重传、带选择确认的重传（SACK）和重复 SACK 四种</strong> 。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令总结</title>
    <link href="/2025/05/13/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <url>/2025/05/13/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><p>思维导图</p><p><img src="/2025/05/13/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/linux.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM知识总结</title>
    <link href="/2025/05/13/JVM%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <url>/2025/05/13/JVM%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM知识相关总结"><a href="#JVM知识相关总结" class="headerlink" title="JVM知识相关总结"></a>JVM知识相关总结</h1><p>JVM是Java底层的实现， 从对象的视角而言，包含了整个对象是如何创建，使用，并且销毁的 。</p><p>对象所处的位置 ，线程私有和共有，主要是程序计数器，虚拟机栈 ，本地方法栈，堆， 方法区 。后两者为公有 。</p><p>了解和熟悉JVM ，可以帮助理解Java为何可以多平台， 因为Java虚拟机的存在，让Java实现了一次编译 ，多平台运行 ， 同时也明白了Java的编译方法，包括JIT。</p><p>从组织架构而言，从文件读入内存， 到程序运行，到内存的回收，其实就是整个JVM的使命 。</p><p>首先 ，类加载器 ，负责加载Class文件 ，将二进制数据读入内存。到位置后，就可以正常跑起来 ，这就涉及到了运行时的数据区域，包含方法区、堆、虚拟机栈、本地方法栈 。</p><p>JVM的核心， 负责执行字节码，包括虚拟处理器，即时编译器（JIT）和垃圾回收器 。</p><p>上面，我们把读入内存，运行时内存说了，就到了回收内存 。</p><p>这就涉及到了垃圾回收 ，这是Java的一大特色，大二的时候，学习数据结构时， 用C++实现 ，C++是需要手动清理、回收内存的。而Java具有自动 回收对象占用的内存的特性 。</p><p>说到垃圾回收 ，就必须要了解垃圾回收的区域， 垃圾回收算法，垃圾回收器 ，如何判定对象是垃圾 。</p><p>全部的JVM的知识 ，了解完之后 ，在实际的生产开发中，就可以明白，如何进行JVM调优。</p><p>虽然我们已经知道了底层的JVM结构，但是这些对我们是不可见的 。</p><p>这就涉及到性能监控工具 ，包括，命令行工具、可视化工具、以及第三方工具。发现问题之后 ，进行JVM的参数配置 ，包括堆内存的大小 ，垃圾回收器，并行收集参数 ，GC日志 ，</p><p>常见的问题包括CPU彪高 ，内存泄露，fullGC 。</p><p>整体知识的思维导图：</p><p><img src="/2025/05/13/JVM%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/markmap-2025513zj.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU占用过高的排查经历</title>
    <link href="/2025/05/12/CPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E7%9A%84%E6%8E%92%E6%9F%A5%E7%BB%8F%E5%8E%86/"/>
    <url>/2025/05/12/CPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E7%9A%84%E6%8E%92%E6%9F%A5%E7%BB%8F%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="CPU占用过高的排查经历"><a href="#CPU占用过高的排查经历" class="headerlink" title="CPU占用过高的排查经历"></a>CPU占用过高的排查经历</h1><p>使用top命令查看CPU的占用情况 ，找到占用CPU较高的进程ID  ，</p><p><img src="/2025/05/12/CPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E7%9A%84%E6%8E%92%E6%9F%A5%E7%BB%8F%E5%8E%86/jvm-20240527111502.png"></p><p>jstack命令查看对应进程的线程堆栈信息</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">jstack -l &lt;pid&gt; &gt; thread-dump.txt<br></code></pre></td></tr></table></figure><p>使用top命令查看进程中线程的占用情况 ，找到占用CPU较高的线程ID ，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">top</span> -H -<span class="hljs-selector-tag">p</span> &lt;pid&gt;<br></code></pre></td></tr></table></figure><p>注意：需要将显示线程的ID转化为16进制， 因为top命令显示的线程ID是十进制的 ，而jstack输出的是十六进制 </p><p>转化：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;<span class="hljs-variable">%x</span>\n&quot;</span> PID<br></code></pre></td></tr></table></figure><p>在jstack的输出中搜索这个十六进制的线程ID ，找到对应的堆栈信息 ；</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-string">&quot;Thread-5&quot;</span> #21 <span class="hljs-attribute">prio</span>=5 <span class="hljs-attribute">os_prio</span>=0 <span class="hljs-attribute">tid</span>=0x00007f812c018800 <span class="hljs-attribute">nid</span>=0x1a85 runnable [0x00007f811c000000]<br>   java.lang.Thread.State: RUNNABLE<br>    at com.example.MyClass.myMethod(MyClass.java:123)<br>    at <span class="hljs-built_in">..</span>.<br></code></pre></td></tr></table></figure><p>最后，根据堆栈信息定位到具体的业务方法，查看是否有死循环、频繁的垃圾回收、资源竞争导致的上下文频繁切换等问题。</p><p>内存飙高问题 </p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/05/04/%E4%BB%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%88%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E7%90%86%E8%A7%A3/"/>
    <url>/2025/05/04/%E4%BB%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%88%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>title: 从信号量到分布式锁 ——并发的解决方法以及理解<br>date: 2024-12-04 20:25:36<br>tags: 技术理解</p><h1 id="从信号量到分布式锁-——并发的解决方法以及理解"><a href="#从信号量到分布式锁-——并发的解决方法以及理解" class="headerlink" title="从信号量到分布式锁 ——并发的解决方法以及理解"></a>从信号量到分布式锁 ——并发的解决方法以及理解</h1><p><strong>并发问题如何解决?</strong></p><p>并发的本质是对有限资源的不对等抢占 。</p><h2 id="操作系统底层"><a href="#操作系统底层" class="headerlink" title="操作系统底层"></a>操作系统底层</h2><p>我们从线程出发，因为线程是操作系统能够进行运算调度的最小单位  ，线程同步其中一种方法是信号量 ，信号量通常表示资源的数量 ，通过两个原子操作的系统调用函数来控制信号量 ，P、V操作， 进入减一 ，退出加一  ，等于0时阻塞 ，相当于互斥锁抢占了资源；当你明白了这个原理 ，就可以理解全部的并发解决方案 。</p><h2 id="Java的解决方法"><a href="#Java的解决方法" class="headerlink" title="Java的解决方法"></a>Java的解决方法</h2><h3 id="单体服务上"><a href="#单体服务上" class="headerlink" title="单体服务上"></a>单体服务上</h3><p>首先 ，volatile关键字， 实现的是内存的可见性 ，相当于大家都可以看到的信号量 ，而synchronized ，在jdk1,7的实现中 ，与信号量的操作是一样 ，底层用的是操作系统的monitorenter 和monitorexit ，这是通过修饰代码块所采用的方法；修饰普通方法时 ， JVM 会通过 <code>ACC_SYNCHRONIZED</code> 标记符来实现同步 ， 你可以发现 ，他们是一样的 。如何不止一个线程，更多的资源需要同步一个资源 ，那么 ，标识依旧保留 ，把等待的资源串起来， 这个时候，就是一个经典的AQS ， AQS实现是由一个共享变量state和一个线程等待队列 ，更巧的是  ，state由volatile变量修饰 ，而AQS就是ReetrantLock的底层实现 。</p><p>这个时候 ，你明白了线程资源的抢占 ，操作系统底层是由互斥锁和信号量 ，而到Java这里 ，有三个类似的 ，volatile ，实现的是内存的可见性 ，synchronized采用的是类似信号量的操作机制， 底层用的是操作系统的monitorenter 和monitorexit ，AQS ，是利用一个信号量加队列的方式实现 。</p><p>单体的我们已经解决了。</p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>而分布式时 ，会出现的问题是 ，没有一个类似volatile变量的东西，让变量对于所有的实例都是可见的 ，并且实时更新的 。</p><p>这个时候 ，CAP理论，可以给我们指导 ，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）这 3 个基本需求，最多只能同时满足其中的 2 个。</p><p>简单而言 ，你不能同时要求提供的服务一直都是可用的，并且数据多副本完全一致 ，在遇到网络故障时 ，依旧保持一致性和可用性  。常见的分布式锁是 ，MySQL分布式锁 ，zookeeper分布式锁，Redis分布式锁 ；MySQL分手锁不常用 ，因为属于数据库IO操作 ，效率不高  ；zookeeper分布式锁保证的是CP ，redis分布式锁保证的是 AP。</p><p>看下对比：</p><p>Redis分布式锁：它追求的高可用性和分区容错性。Redis在追求高可用性时会在 Redis 写入主节点数据后，立即返回成功，不关心异步主节点同步从节点数据是否成功。Redis是基于内存的，性能极高，官方给的指标是每秒可达到10W的吞吐量。</p><p>Zookeeper分布式锁：它追求的是强一致性和分区容错性。Zookeeper在写入主节点数据后会等到从节点同步完数据成后才会返回成功。为了数据的强一致性牺牲了一部分可用性。</p><p>而在大部分的高并发场景下， 我们需要的都是可用性 ，redis分布式锁就是大部分锁采用的方案 。</p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>在分布式SOA设计原则的基础上 ，发展出了微服务架构</p><p>将单体的服务拆分成多个小型、自治且松耦合的服务 。</p><p>微服务的两个重点关注点， 拆分服务以及服务治理 。</p><p>我们看下思维导图</p><p><img src="/2025/05/04/%E4%BB%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%88%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E7%90%86%E8%A7%A3/=mg%5Cfenbushi.png" alt="img"></p><p><img src alt="img"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统总结</title>
    <link href="/2025/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/"/>
    <url>/2025/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="/2025/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1747105098786.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络总结</title>
    <link href="/2025/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"/>
    <url>/2025/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="/2025/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1747105304702.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring总结</title>
    <link href="/2024/10/13/Spring%E6%80%BB%E7%BB%93/"/>
    <url>/2024/10/13/Spring%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring总结"><a href="#Spring总结" class="headerlink" title="Spring总结"></a>Spring总结</h1><p>一个开发框架，是简化了复杂配置，支持快速集成的框架，实现了IOC和AOP  ，控制反转和面向切面。</p><p>对象的管理变得更加简单 ，简化了开发不必的逻辑。让我们更专注于业务场景 。</p><p>思维导图：</p><p><img src="/2024/10/13/Spring%E6%80%BB%E7%BB%93/spring%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日算法-18</title>
    <link href="/2024/09/16/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-18/"/>
    <url>/2024/09/16/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-18/</url>
    
    <content type="html"><![CDATA[<p>关于一些必须记忆的函数</p><p>charAt() ; 返回对应位置的字符；</p><p>getOrDefault（）；V getOrDefault(Object key, V defaultValue)</p><p>containsKey（）；是否包含这个键</p><p>import java.util.Arrays;<br>import java.util.LinkedList;</p><p>class Solution {<br>    public int[][] merge(int[][] intervals) {<br>        &#x2F;&#x2F; 使用链表来存储合并后的区间，方便动态地添加和删除元素<br>        LinkedList&lt;int[]&gt; res &#x3D; new LinkedList&lt;&gt;();<br>        &#x2F;&#x2F; 按照每个区间的起始值对区间数组进行升序排序<br>        Arrays.sort(intervals, (o1, o2) -&gt; Integer.compare(o1[0], o2[0]));</p><pre><code class="hljs">// 先将第一个区间加入结果链表中    res.add(intervals[0]);// 从第二个区间开始遍历所有区间    for (int i = 1; i &lt; intervals.length; i++) &#123;        // 如果当前区间的起始值小于等于结果链表中最后一个区间的结束值，说明有重叠        if (intervals[i][0] &lt;= res.getLast()[1]) &#123;            // 取出结果链表中最后一个区间的起始值            int start = res.getLast()[0];            // 计算合并后的区间的结束值，取当前区间和结果链表中最后一个区间结束值的较大值            int end = Math.max(intervals[i][1], res.getLast()[1]);            // 将结果链表中最后一个区间删除            res.removeLast();            // 将合并后的新区间加入结果链表            res.add(new int[]&#123;start, end&#125;);        &#125; else &#123;            // 如果没有重叠，则直接将当前区间加入结果链表            res.add(intervals[i]);        &#125;    &#125;// 将链表转换为二维数组并返回    return res.toArray(new int[res.size()][]);&#125;</code></pre><p>}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testExport</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建表头列表，包含员工编号、姓名、性别、手机号、金额等字段名称</span><br>    List&lt;String&gt; heads = ListUtils.newArrayList(<span class="hljs-string">&quot;员工编号&quot;</span>, <span class="hljs-string">&quot;姓名&quot;</span>, <span class="hljs-string">&quot;性别&quot;</span>, <span class="hljs-string">&quot;手机号&quot;</span>, <span class="hljs-string">&quot;金额&quot;</span>);<br>    <span class="hljs-comment">// 用于存储所有数据的列表，首先添加表头</span><br>    List&lt;List&lt;String&gt;&gt; dataList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    dataList.add(heads);<br><br>    <span class="hljs-comment">// 通过循环生成模拟数据</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>) &#123;<br>        i++;<br>        <span class="hljs-comment">// 每一行数据都是一个包含员工编号、姓名、性别、手机号和金额的列表</span><br>        dataList.add(ListUtils.newArrayList(String.valueOf(i), <span class="hljs-string">&quot;王&quot;</span>+i, i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>? <span class="hljs-string">&quot;男&quot;</span> : <span class="hljs-string">&quot;女&quot;</span>, <span class="hljs-string">&quot;1234456&quot;</span>, <span class="hljs-string">&quot;666.88&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 指定输出的 Excel 文件名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;export.xlsx&quot;</span>;<br>    <span class="hljs-comment">// 使用 EasyExcel 进行写入操作，指定文件名、工作表名称为&quot;员工&quot;，并将数据写入文件</span><br>    EasyExcel.write(fileName).sheet(<span class="hljs-string">&quot;员工&quot;</span>).doWrite(dataList);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日算法-17</title>
    <link href="/2024/09/11/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-17/"/>
    <url>/2024/09/11/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-17/</url>
    
    <content type="html"><![CDATA[<p>滑动窗口</p><p>长度最小的子数组</p><p>这是关于双指针的问题；思路是没有问题的，但是跑不完用例。</p><p>记录result的应该初始化为Integer.MAX_VALUE; 因为极端情况也是我们需要考虑的。</p><p>同时明白移动指针的时间的顺序，精确到各个数据的细节，思维要严谨。</p><p>回溯法，注意模板</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">void backtracking(参数) &#123;<br>    if (终止条件) &#123;<br>        存放结果;<br>        return;<br>    &#125;<br><br>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); // 递归<br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有进就有退，不要忘记退了。有进有退才叫做回溯。标记数组，结果数组存储的采用ArrayList，可以动态扩容；暂时的存储的采用LinkedList，适合频繁的增删；</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日算法-16</title>
    <link href="/2024/09/06/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-16/"/>
    <url>/2024/09/06/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-16/</url>
    
    <content type="html"><![CDATA[<h2 id="快速排序："><a href="#快速排序：" class="headerlink" title="快速排序："></a>快速排序：</h2><p>基于分治思想</p><p>先分区，确立分区逻辑</p><h2 id="无重复字符-的最长子串"><a href="#无重复字符-的最长子串" class="headerlink" title="无重复字符 的最长子串"></a>无重复字符 的最长子串</h2><p>利用哈希和滑动窗口；</p><p>滑动窗口更新边界</p><p>哈希记录字符出现的位置</p><h2 id="LRU缓存机制"><a href="#LRU缓存机制" class="headerlink" title="LRU缓存机制"></a>LRU缓存机制</h2><p>利用双向循环列表，模拟LRU的过程，哈希</p><p>put 和get都是以O(1)的时间复杂度，双向循环链表可以满足条件</p><p>初始化容量</p><p>写函数get </p><p>写函数put</p><p>利用java自带的LinkedHashMap通过双向链表维护元素的顺序，其中， remove 和put 操作，</p><p>访问时，先remove。再put ，就可以更新或者添加到末尾</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日算法-15</title>
    <link href="/2024/07/31/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-15/"/>
    <url>/2024/07/31/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-15/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h2>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目笔记-9</title>
    <link href="/2024/07/30/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-9-1/"/>
    <url>/2024/07/30/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-9-1/</url>
    
    <content type="html"><![CDATA[<p>说明快捷键： ctrl +  q</p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日算法-14</title>
    <link href="/2024/07/28/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-14/"/>
    <url>/2024/07/28/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-14/</url>
    
    <content type="html"><![CDATA[<p>动态规划</p><p>不相交的线</p><p>最大子序列和</p><p>判断子序列</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日算法-13</title>
    <link href="/2024/07/27/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-13/"/>
    <url>/2024/07/27/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-13/</url>
    
    <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><h4 id="关于初始化"><a href="#关于初始化" class="headerlink" title="关于初始化"></a>关于初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.fill(dp, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>详细解释：</p><ul><li><code>Arrays.fill(array, value)</code>：将 <code>array</code> 数组的所有元素都设置为 <code>value</code>。</li><li><code>dp</code>：是你要填充的数组。</li><li><code>1</code>：是你要填充到数组每个元素的值。</li></ul><p>关于思想</p><h3 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h3><p>简化成一维遍历，然后对比的是上一个即可。</p><h3 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h3><p>逐个对比</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>知识点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">charchar1 = text1.charAt(i-<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><code>char char1 = text1.charAt(i-1);</code> 是 Java 中用于从字符串 <code>text1</code> 中获取指定位置的字符的一种方式。具体来说，这行代码从 <code>text1</code> 字符串中获取第 <code>i-1</code> 个位置上的字符，并将其赋值给变量 <code>char1</code>。</p><p>详细解释如下：</p><ul><li><code>char char1</code>：声明一个 <code>char</code> 类型的变量 <code>char1</code>。</li><li><code>text1</code>：是一个字符串对象。</li><li><code>charAt(i-1)</code>：是 <code>String</code> 类中的一个方法，用于返回字符串中指定索引处的字符。索引从 <code>0</code> 开始计数，因此 <code>charAt(i-1)</code> 表示获取字符串 <code>text1</code> 中第 <code>i-1</code> 个位置的字符。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目笔记-9</title>
    <link href="/2024/07/23/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-9/"/>
    <url>/2024/07/23/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-9/</url>
    
    <content type="html"><![CDATA[<p>关于redis操作部分的数据类型转化问题</p><p>putAll（）函数的调用，在没有将数据类型转化成String，导致出错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String , Object&gt; userMap = BeanUtil.beanToMap(userDTO);<br>Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;(), create().setIgnoreNullValue(<span class="hljs-literal">true</span>).setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));<br></code></pre></td></tr></table></figure><p>对比一二行，第二行 使用了FiledValueEditor，将每个字段的值都转化为String类型</p><p> <strong><code>BeanUtil.beanToMap(userDTO, new HashMap&lt;String, Object&gt;(), create().setIgnoreNullValue(true).setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()))</code></strong> :</p><ul><li>这个方法使用了一个 <code>FieldValueEditor</code>，它将每个字段的值都转换为 <code>String</code> 类型。<code>fieldValue.toString()</code> 的调用确保了无论字段的原始类型是什么，最终都将以 <code>String</code> 类型存储在 <code>Map</code> 中。</li><li>这样，当你将这个 <code>Map</code> 存储到 Redis 时，所有的值都已经是 <code>String</code> 类型，避免了 <code>ClassCastException</code> 的问题</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>类型转换</strong> : 使用 <code>FieldValueEditor</code> 将所有字段值转换为 <code>String</code> 类型，确保了你在存储和序列化数据时不会出现类型不匹配的问题。</li><li><strong>数据一致性</strong> : 这样做确保了在 Redis 存储和检索数据时，一致地处理所有数据为 <code>String</code> 类型，符合 <code>StringRedisSerializer</code> 的要求。</li></ul><p> <strong>改进建议</strong> :</p><ul><li>如果你在不同的地方需要不同的数据类型（如 <code>Long</code> 和 <code>String</code>），考虑使用适当的序列化器或者在应用层处理数据类型转换。</li><li>确保所有操作 Redis 的地方数据类型一致，可以有效减少类似的问题。</li></ul><p>你现在的解决方案是通过强制将所有字段值转换为 <code>String</code>，这在处理 Redis 数据时是一种有效的方式。</p><p>拦截器优化</p><p>两个拦截器</p><p>第一个刷新</p><p>第二个拦截需登录new</p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日算法-12</title>
    <link href="/2024/07/23/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-12/"/>
    <url>/2024/07/23/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-12/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h2><h3 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a>最佳买卖股票时机含冷冻期</h3><p>状态较为复杂，定义四种状态的dp数组，初始化时根据公式判断；</p><p>分解为 ： 持股 ； 不持有股票（保持卖出状态 ， 今天卖出） ；冷冻状态</p><h3 id="买卖股票的最佳时间含手续费"><a href="#买卖股票的最佳时间含手续费" class="headerlink" title="买卖股票的最佳时间含手续费"></a>买卖股票的最佳时间含手续费</h3><p>这是关于买卖II的变形，只要在卖出&#x2F;买入时考虑手续费即可，其余相同</p><h3 id="股票问题总结"><a href="#股票问题总结" class="headerlink" title="股票问题总结"></a>股票问题总结</h3><p>最关键的是如何分解股票的各个状态；如何用dp数组去定义，然后根据定义推出递推公式，再初始化，尤其要关注定义不能混淆。要清晰分解可能的状态。而递推公式；考虑的其实都是如何从前一个状态到后一个状态，就像爬楼梯一样；无非是决定走哪一步，走不走的问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日八股-6</title>
    <link href="/2024/07/21/%E6%AF%8F%E6%97%A5%E5%85%AB%E8%82%A1-6/"/>
    <url>/2024/07/21/%E6%AF%8F%E6%97%A5%E5%85%AB%E8%82%A1-6/</url>
    
    <content type="html"><![CDATA[<p>BigDecimal避免精度丢失</p>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日算法-11</title>
    <link href="/2024/07/20/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-11/"/>
    <url>/2024/07/20/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-11/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="买股票的最佳时机II"><a href="#买股票的最佳时机II" class="headerlink" title="买股票的最佳时机II"></a>买股票的最佳时机II</h2><p>思考：</p><p>递归性：</p><ul><li>dp[i][0] 表示第i天持有股票所得现金。</li><li>dp[i][1] 表示第i天不持有股票所得最多现金</li></ul><p>第i天持有股票即dp[i][0]，如果是第i天买入股票，所得现金就是昨天不持有股票的所得现金 减去 今天的股票价格 即：dp[i - 1][1] - prices[i]</p><p>如果第i天不持有股票即dp[i][1]的情况， 依然可以由两个状态推出来</p><ul><li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]</li><li>第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i - 1][0]</li></ul><p>还需加深理解数组含义</p><h2 id="买股票III"><a href="#买股票III" class="headerlink" title="买股票III"></a>买股票III</h2><p>两笔交易，但是不可同时进行</p><p>定义</p><p>初始化</p><p>递推公式</p><p>其实再复杂的问题，都可以回归到爬楼梯问题上，我是如何到这个楼梯的，一开始我又在哪里，我该如何爬楼梯；最终会到哪里</p><p>这个题目的细节处理很关键，弄明白各个阶段的dp数组的定义，</p><h2 id="IV"><a href="#IV" class="headerlink" title="IV"></a>IV</h2><p>k笔交易</p><p>范围扩到dp[i] [2k]</p><p>初始化与3类似，奇数和偶数分开</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日算法-10</title>
    <link href="/2024/07/19/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-10/"/>
    <url>/2024/07/19/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-10/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍|||"></a>打家劫舍|||</h2><p>结合二叉树</p><p>后序遍历，每次只取最大的子树，判断是否偷根节点。</p><p>递归</p><p>树形DP，如何把树转化成数组，将陌生转化为熟悉，结合前面已经知道的二叉树遍历。</p><h2 id="买股票的最佳时机"><a href="#买股票的最佳时机" class="headerlink" title="买股票的最佳时机"></a>买股票的最佳时机</h2>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日八股-5</title>
    <link href="/2024/07/18/%E6%AF%8F%E6%97%A5%E5%85%AB%E8%82%A1-5/"/>
    <url>/2024/07/18/%E6%AF%8F%E6%97%A5%E5%85%AB%E8%82%A1-5/</url>
    
    <content type="html"><![CDATA[<p>java基础：</p><h2 id="java-SE-和-java-EE"><a href="#java-SE-和-java-EE" class="headerlink" title="java SE 和 java EE"></a>java SE 和 java EE</h2><p>SE 基础版，桌面和简单应用程序</p><p>  EE高级版本，复杂应用和企业应用程序</p><p>java ME 微型版本， 嵌入式消费电子设备的应用程序</p><h2 id="JVM-，JDK-，-JRE"><a href="#JVM-，JDK-，-JRE" class="headerlink" title="JVM ，JDK ， JRE"></a>JVM ，JDK ， JRE</h2><p>JVM java虚拟机 运行java 字节码的 虚拟机</p><p>一次编译，随处可以运行</p><p>JDK 和 JRE</p><p>JDK 功能齐全的java SDK ，包含了JRE</p><h2 id="字节码的好处"><a href="#字节码的好处" class="headerlink" title="字节码的好处"></a>字节码的好处</h2><p>JVM可以理解的代码叫做字节码，不面向任何特定处理器，只面向虚拟机。字节码经过解释器（非热点代码）&amp;编译器（JIT）<strong>JIT（Just in Time Compilation）（热点代码处理）</strong>的处理就可以变成机器可以理解的代码</p><h2 id="java-语言-编译和解释并存"><a href="#java-语言-编译和解释并存" class="headerlink" title="java 语言 编译和解释并存"></a>java 语言 编译和解释并存</h2><p>java编译生成字节码，字节码解释生成机器码</p><h2 id="AOT"><a href="#AOT" class="headerlink" title="AOT"></a>AOT</h2><p><strong>AOT(Ahead of Time Compilation)   编译模式</strong></p><p>与JIT不同，执行前编译成机器码， 属于静态编译</p><p>避免了JIT预热， 提高启动速度，避免预热时间长</p><p>减少内存占用和增强java 程序的安全性（不容易被反编译和修改）适合云原生场景（云原生，一类技术统称，易于构建弹性扩展的应用程序）</p><p>AOT 启动时间，内存占用和打包体积占优势 ； JIT 具备极高的极限处理能力，可以降低请求的最大延迟。说白了</p><p>GraalVM ，高性能JDK ， 能运行Java和其他JVM语言 ， 以及JavaScript和python等非jvm语言</p><p>AOT编译和JIT编译均可</p><h2 id="AOT和JIT优缺点"><a href="#AOT和JIT优缺点" class="headerlink" title="AOT和JIT优缺点"></a>AOT和JIT优缺点</h2><p>AOT适用于云原生，以及微服务架构</p><p>不支持Java的部分动态特性 如反射， 动态代理，动态加载 ， JNI（ Java Native Interface） Java本地接口方法，允许Java调用本地代码，部分架构和库需要用到这些特性而用AOT编译，则无法使用。</p><p>AOT提前编译</p><p>JIT即时编译器</p><h2 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h2><p>云原生：开发，部署， 管理相对于传统的应用程序更加的高效和便捷；提高开发效率，说白了，就是一个平台，大家把东西放上面，更容易一起构建，部署，管理。微服务化架构</p><h2 id="OracleJDK和openJDK"><a href="#OracleJDK和openJDK" class="headerlink" title="OracleJDK和openJDK"></a>OracleJDK和openJDK</h2><p>扩展; BCL协议 :使用JDK（可商用），不可修改</p><p>OTN协议：私下用，商用需付费</p><h2 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h2><p>都面向对象的语言， 支持封装，继承和多态， Java三大特性：继承，封装，多态</p><p>不同：</p><p>Java不提供指针直接来直接访问内存，程序内存更加安全</p><p>Java类单继承， C++多重继承；但是Java接口可多继承；多继承：一个接口可以继承多个类，一个类可以实现多个接口 </p><p>意义：多个父类有重复方法和属性时，子类的调用结果会不清；而用接口，可以小范围调用</p><p>Java自动内存管理垃圾回收机制（GC） ， 无需手动释放内存</p><p>C++方法重载和操作符重载，但Java仅方法重载； 操作符重载增加了复杂性</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>注释</p><p>标识符</p><p>关键字（赋予特殊含义的标识符）</p><p>自增自减运算符</p><p>移位运算符（常常不会用）</p><p>&lt;&lt;:左移位运算符；高丢低补； x&lt;&lt; n ; 相当于x乘2的n次方</p><p><code>&gt;</code>&gt;:带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; n</code>,相当于 x 除以 2 的 n 次方</p><h2 id="continue-break-return"><a href="#continue-break-return" class="headerlink" title="continue , break  , return"></a>continue , break  , return</h2><ol><li><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</li><li><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。</li></ol><p><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p><ol><li><code>return;</code>：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li><code>return value;</code>：return 一个特定值，用于有返回值函数的方法</li></ol><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Java 中有 8 种基本数据类型，分别为：</p><ul><li>6 种数字类型：<ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li>1 种字符类型：<code>char</code></li><li>1 种布尔型：<code>boolean</code>。</li></ul><p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code></p><h2 id="包装类型相关"><a href="#包装类型相关" class="headerlink" title="包装类型相关"></a>包装类型相关</h2><p>包装类型的缓存机制</p><p>整型包装类型对象之间值的比较，用equals方法比较</p><p>自动装箱与拆箱：</p><p>包装的意义：Java面向对象，基本 类型没有对象的性质，包装后，包装类型有了对象的性质，可以添加属性和方法，丰富了基本类型的操作</p><h2 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h2><p>重载：同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>同一个类中，方法名必须相同，参数类型、个数、顺序不同；方法返回值和访问修饰符可以不同</p><p>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理</p><p>重写：当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类的方法</p><p>运行期间，子类对父类的允许访问的方法的实现过程进行重新编写。</p><p>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</p><p><img src="/2024/07/18/%E6%AF%8F%E6%97%A5%E5%85%AB%E8%82%A1-5/../../../image/%E6%AF%8F%E6%97%A5%E5%85%AB%E8%82%A1-5/1721457064512.png" alt="1721457064512"></p>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日八股-4</title>
    <link href="/2024/07/17/%E6%AF%8F%E6%97%A5%E5%85%AB%E8%82%A1-4/"/>
    <url>/2024/07/17/%E6%AF%8F%E6%97%A5%E5%85%AB%E8%82%A1-4/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>项目笔记-8</title>
    <link href="/2024/07/17/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-8/"/>
    <url>/2024/07/17/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-8/</url>
    
    <content type="html"><![CDATA[<h2 id="关于如何排查错误"><a href="#关于如何排查错误" class="headerlink" title="关于如何排查错误"></a>关于如何排查错误</h2><p>刨根问底，递归性的看，看后面的错误，要找到背后最根本的原因，而不是一直卡在第一个报错的地方，只有递归性的理解了各个日志的含义，或者说知道报错从哪个地方找，以后才能自己独立的解决问题。</p><p>接着推进项目的进程</p><p>这次报错，主要是redis配置和mysql配置不当；redis设置了密码，但是没有在conf文件里面设置密码；没有正确配置；mysql没有正确配置用户名，仅仅是配置了密码，相当于有了钥匙但是没有找到相对应的门。</p><p>总结与反思：学会如何分解问题，多问几个为什么，多学多问多思考，自己也可以多多尝试，排除法，而不是一直走老路，一直犯同样的错误。只有不断纠正学习，才能更好的进步。</p><h2 id="关于如何深入学习"><a href="#关于如何深入学习" class="headerlink" title="关于如何深入学习"></a>关于如何深入学习</h2><p>从业务逻辑出发，思考项目所运用的技术点，然后想明白为什么要用这个方案，有没有别的方案，别的方案的优劣之处又在哪里？发散性的思考，又深入性的思考，做到既有深度，又有广度。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>项目笔记-7</title>
    <link href="/2024/07/13/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7/"/>
    <url>/2024/07/13/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-7/</url>
    
    <content type="html"><![CDATA[<p>redis报错，显示已经连接成功，但是一输验证码就报错</p><p>排查后代码没有问题；找不到原因；死耗着没有效果</p><p>note：以后如果是某个软件或者配置出了问题，一定时间内找不到，直接重装；不要一直卡在那里</p><p>理论与实践还是有差距的，多动手自己去敲一下代码，运行不报错才行；而不是看看就行了</p><p>装虚拟机，配ubunt</p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日算法-9</title>
    <link href="/2024/07/13/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-9/"/>
    <url>/2024/07/13/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-9/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h2><p>反向；用字典装满字符串</p><p>dp数组的含义：字符串的长度为i，dp[i] true</p><p>dp[0]空字符串</p><p>dp[s.size]</p><p>if([j, i ) , &amp;&amp; dp[i]){</p><p>   true</p><p>}</p><p>dp[0]&#x3D; true</p><p>组合数和排列数</p><p>排列数，有顺序；先包</p><p>for(i&#x3D;1 ; i&lt; &#x3D; s. size ; i++){<br>    for(j&lt;0 , j&lt; i ; j++){</p><pre><code class="hljs">截取后是否在字典里；</code></pre><p> true；</p><p>}</p><p>打印</p><p>}</p><p>知识点：截取字符串：s.substring(j , i)</p><p>判读包含：set.contains( );</p><p>多重背包</p><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><h2 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II"></a>打家劫舍II</h2><p>有环路，可以断开，分成两份，然后判断最大值；只是nums[]的取值单位不一样；一份是不取第一个，一份是不取最后一个。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日八股-3</title>
    <link href="/2024/07/13/%E6%AF%8F%E6%97%A5%E5%85%AB%E8%82%A1-3/"/>
    <url>/2024/07/13/%E6%AF%8F%E6%97%A5%E5%85%AB%E8%82%A1-3/</url>
    
    <content type="html"><![CDATA[<p>物理内存的结构</p><h2 id="一致性访问内存UMA架构"><a href="#一致性访问内存UMA架构" class="headerlink" title="一致性访问内存UMA架构"></a>一致性访问内存UMA架构</h2><p>传输均经过总线</p><p>扩宽总线成本高，面临性能和扩展性问题</p><h2 id="非一致性内存访问NUMA架构"><a href="#非一致性内存访问NUMA架构" class="headerlink" title="非一致性内存访问NUMA架构"></a>非一致性内存访问NUMA架构</h2><p>非整块</p><p>CPU访问本地内存较快，但是访问其他节点就会慢很多，导致速度不一致，所以叫做非一致性内存访问架构</p><p>内存分配策略</p><p>note：需要明白的是，工程需要和课堂上的教学是不一样的，基于业务逻辑和具体需要去理解各个点，这东西解决了什么问题，带着问题出发，从问题去思考，然后想着，如何运用在开发中，无论是运用这个技术，还是学习它的设计思想，都对思维体系和开发能力有益。而不是仅仅知道个概念，不明白其由来和作用，那大脑只能是个比较好的存储器。发现问题，这个东西基于什么思想提出，解决方案明白之后，再去理解它底层所运用的东西，相应的数据结构，算法；从下到上，再从上到下；深刻的分析问题，再解决问题。</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>核心思考点：管理和分配</p><p>注意学习Linux</p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>哲学家问题：解决 了互斥访问有限的竞争问题一类的建模过程</p><p>读者问题：数据库访问建模</p>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日八股-3</title>
    <link href="/2024/07/12/%E6%AF%8F%E6%97%A5%E5%85%AB%E8%82%A1-2/"/>
    <url>/2024/07/12/%E6%AF%8F%E6%97%A5%E5%85%AB%E8%82%A1-2/</url>
    
    <content type="html"><![CDATA[<p>6.linux虚拟内存管理</p><p>7.Linux物理内存管理</p><p>连续和非连续</p><p>FLATMEM 和DISCONTIGMEM</p>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日算法-8</title>
    <link href="/2024/07/12/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-8/"/>
    <url>/2024/07/12/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-8/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="322零钱兑换"><a href="#322零钱兑换" class="headerlink" title="322零钱兑换"></a>322零钱兑换</h2><p>零钱无数</p><p>兑换零钱总数 背包</p><p>组合数</p><p>dp[j]装满容量为j，最少物品dp[j]</p><p>递推公式  ：  dp[j] &#x3D;min( dp[j-coins[i]]+1 ,dp[j]);</p><p>初始化：min;应该初始化为最大值 dp[0] &#x3D; 0;</p><p>先物品后背包（组合）</p><p>先背包后物品（排列）背包内元素的次序</p><p>不影响，因为是最小</p><p>for(int i &#x3D; 0 ; i&lt; coins.length; i++){</p><pre><code class="hljs">for(j=coins[i] ; j&lt;=amount ;j++)&#123;</code></pre><p>}</p><p>}</p><p>不断分解</p><h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h2><p>与上一题类似</p><p>dp[j] &#x3D; min(dp[j] , dp[j-i*i] +1)</p><p>i&#x3D; 1 ；i*i &lt; &#x3D; n; </p><p>j&#x3D;i*i；j&lt;&#x3D;n;</p><p>注意顺序</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目笔记-6</title>
    <link href="/2024/07/12/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-6/"/>
    <url>/2024/07/12/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-6/</url>
    
    <content type="html"><![CDATA[<p>redis短信登录功能</p><p>只要用户一直访问，不断更新有效期</p><p>redis的token有效期</p><p>实现：拦截器</p><p>关于注入技巧</p><p>基于public 下写时，注意注入别的类，才可以访问</p><p>spring 创建的对象可以自动注入；自己new的函数往往是无法利用spring实现依赖注入的，自带的才可以，用到的时候再去手动注入</p><p>关于这个问题，不需要手动注入， 可以找到用到它的类；且该类是由spring自动注入的；其实就是把自己创建的和spring自动的相互关联起来，避免手动注入的繁琐和复杂性、</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Configuration</span><br></code></pre></td></tr></table></figure><p>说明将来由spring创建</p><p>然后利用@Resource获取手动创建的与之关联</p><p>Alt + insert 调出generate 选择 constructor，自动构造函数；</p><h2 id="注意使用各种快捷键以及自带的方法提升开发效率-，这是我们需要了解的。"><a href="#注意使用各种快捷键以及自带的方法提升开发效率-，这是我们需要了解的。" class="headerlink" title="注意使用各种快捷键以及自带的方法提升开发效率 ，这是我们需要了解的。"></a>注意使用各种快捷键以及自带的方法提升开发效率 ，这是我们需要了解的。</h2><p>IDEA如何打开recent files快捷键  Ctrl + e  </p><p>Ctrl + e</p><p>IntelliJ IDEA中，** Ctrl + e** 是一组非常便捷的快捷键，用以快速查找和打开最近使用过的文件，如图 另，在 File -&gt; Setting -&gt; Editor -&gt; General 下可以设置 Ctrl + e 弹出层显示的记录文件个数，如图 </p><p>关于@Resource 注解 </p><p>和@Autowired 用法类似； 从容器中自动获取bean</p><p><a href="https://blog.csdn.net/u010502101/article/details/78950045">@Resource注解用法_@resource使用-CSDN博客</a></p><p>Ctrl + B 跳转到引用类</p><h3 id="关于IDEA代码自动补全"><a href="#关于IDEA代码自动补全" class="headerlink" title="关于IDEA代码自动补全"></a>关于IDEA代码自动补全</h3><p> .var自动补全</p><p>关于redis函数的调用，当有map时，说明不是一个值，而是返回key关联的全部值</p><p>设置redis数据自动过期时间</p><p>expire（）函数</p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目笔记-5</title>
    <link href="/2024/07/11/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-5/"/>
    <url>/2024/07/11/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-5/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs">基于redis实现短信登录</code></pre><p>替代session</p><p>putAll方案</p><p>存东西时，最好加上一个前缀，表示业务逻辑</p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日算法-7</title>
    <link href="/2024/07/11/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-7/"/>
    <url>/2024/07/11/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-7/</url>
    
    <content type="html"><![CDATA[<p>动态规划总结</p><p>01背包问题</p><p>每个物品的数量只有一个，选或者不选，01背包</p><p>max(dp[j], dp[j - weight[i]] + value[i])根据一个的重量和价值一起判断，是否要取这个物品。</p><p>动规的五部曲：</p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><p>其实只要把各个问题的东西抽象成背包，物品 ， 价值，容量，自己确定了推导公式，根据题目的提示初始化dp[i],再举例手动画一个遍历的过程，问题就变得简单了。</p><p>完全背包问题</p><p>1物多次</p><p>for背包改成正序；倒序的时候，只添加了一次</p><p>正序遍历状态图</p><p>顺序：物品和背包可换，上层每次遍历一个 ，下层每次就遍历一轮；每次是写一行还是写一列 </p><p>518.零钱兑换||</p><p>求组合数，外层为物品，内层为背包</p><p>求排列数，外层为背包，内层为物品</p><p>377.组合总和IV</p><p>排列</p><p>先背包后物品，举例子证明</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日八股</title>
    <link href="/2024/07/11/%E6%AF%8F%E6%97%A5%E5%85%AB%E8%82%A1/"/>
    <url>/2024/07/11/%E6%AF%8F%E6%97%A5%E5%85%AB%E8%82%A1/</url>
    
    <content type="html"><![CDATA[<p>操作系统</p><p>4.在4G的物理内存的机器上申请8G的内存会如何？、</p><p>操作系统虚拟内存大小</p><p>和操作系统的位数大小有关</p><p>32位操作系统，进程理论上只能申请最大为3GB的虚拟内存；直接申请8G，失败；64位，最大可以申请128TB；（）</p><ul><li>2^32 &#x3D; 4,294,967,296 个地址。</li><li>每个地址代表一个字节（Byte），所以地址空间大小就是 4,294,967,296 字节，即 4GB</li></ul><p>申请，不一定用上</p><p>swap机制的作用</p><p>无swap分区，会导致OOM（内存溢出）</p><p>note：学会利用Linux模拟，会有更好的效果</p><p>5.如何避免预读失效和缓存污染问题</p><p>预读机制：提前装入，减少磁盘I&#x2F;O次数，提高I&#x2F;O吞吐量</p><p>预读失效：提前加载的没读上</p><p>解决：预读页停留时间尽可能短；保证真正被读取的热数据保留在内存的时间尽可能长</p><p>改进LRU链表</p><p>缓存污染问题：</p><p>活跃LRU链表和非活跃LRU链表；</p><p>批量读时，大量数据进入活跃LRU链表，而热点数据被淘汰，且进入的数据很长一段时间都没有被访问</p><p>解决：提高进入活跃LRU链表的门槛；保证热点数据不会轻易被替换</p><p>6.深入理解Linux虚拟机内存管理</p>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目笔记-4</title>
    <link href="/2024/07/10/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-4/"/>
    <url>/2024/07/10/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-4/</url>
    
    <content type="html"><![CDATA[<p>关于保存用户登录状态信息：</p><p>ThreadLocal ； 作用：java中的一个类，提供线程局部变量，每个访问变量的线程都有其自己独立初始化的变量副本；ThreadLocal实例，隔离的保存各个线程的数据，确保线程之间不会相互干扰，避免因为并发访问导致的数据不一致性问题</p><p>如何正确的启动项目</p><p>ngnix</p><p>redis</p><p>mysql</p><p><a href="http://localhost:8080/login.html">黑马点评</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日算法-6</title>
    <link href="/2024/07/10/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-6/"/>
    <url>/2024/07/10/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-6/</url>
    
    <content type="html"><![CDATA[<p>动态规划</p><p>1.目标和</p><p>问题转化：01背包问题</p><p>加法总和：x；减法总和sum-x</p><p>要求：x-（sum-x） &#x3D; target</p><p>x &#x3D; （target+ sum）&#x2F;2</p><p>装满容量为x的背包，有几种方法</p><p>x；就是bagSize；</p><p>2.一和零</p><p>五部曲；</p><p>背包有两个维度，m, n ；不同长度的字符串就是不同大小的物品</p><p>dp[i][j]最多有i个0和j个1的strs的最大子集的大小为dp[i][j]</p><p>之后计算1，0合；再外层遍历物品，内层遍历背包，倒序；注意类型转化以及代码结构</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八股-1</title>
    <link href="/2024/07/10/%E5%85%AB%E8%82%A1-1/"/>
    <url>/2024/07/10/%E5%85%AB%E8%82%A1-1/</url>
    
    <content type="html"><![CDATA[<p>操作系统：</p><p>内存管理：</p><p>1.为什么要有虚拟内存？</p><p>分页（多级页表，TLB）、分段、段页式内存管理，Linux内存管理</p><p>2.malloc是如何分配内存的？</p><p>非系统调用，函数，动态分配内存</p><p>brk（）；</p><p>mmap（）；</p><p>malloc 通过brk（）申请，free释放时，内存不还操作系统，缓存在mallco池；</p><p>通过mmap（）申请 ，free释放，会把内存归还给操作系统。真正释放</p><p>3.内存满了之后</p><p>后台内存回收，kswaped内核线程</p><p>直接内存回收，</p><p>OOM机制</p><p>SMP架构</p><p>NUMA架构</p><p>保护，不被OOM杀掉：调正进程值：&#x2F;proc&#x2F;[pid]&#x2F;oom_socre_adj值，改变打分</p><p>计算机网络</p><p>Http</p>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目笔记-3</title>
    <link href="/2024/07/09/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3/"/>
    <url>/2024/07/09/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-3/</url>
    
    <content type="html"><![CDATA[<p>项目点：</p><p>1.session集群问题 ； 无法共享会话状态；分了</p><p>解决；redis缓存：可以实现数据共享，提速； 性能提升</p><p>2.设置缓存</p><p>如何设计</p><p>解决缓存存在的问题</p><p>经典双写不一致</p><p>三大缓存问题</p><p>明天多看一点，加油</p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日算法 -5</title>
    <link href="/2024/07/09/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-5/"/>
    <url>/2024/07/09/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-5/</url>
    
    <content type="html"><![CDATA[<p>7月9日算法总结：</p><p>动态规划专题：</p><p>动规五部曲：</p><p>背包问题：1.dp数组以及下标的含义（明白如何代表问题）</p><p>2.确定递归公式</p><p>3.如何初始dp</p><p>数组（这一步常常忽略）</p><p>4.确定遍历顺序（从前往后还是从后往前，物品和背包的先后顺序）</p><p>5.举例推导或打印dp数组检查</p><p>01背包问题：</p><p>1.分割等和子集</p><p>解题思路：平分为两个背包，然后转化成01背包问题；抽象化：nums[i]物品的价值和重量；target（平分后数值）;背包的容量；dp[j]是否能达到和为i的子集</p><p>注意：代码跑通了，也要时常想想为什么，是否还可以更好的优化，而不仅仅局限于一种解法，学会探索其中的乐趣。</p><p>2.最后一块石头的重量</p><p>求背包最多能装多少，和分割子集类似</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM调优</title>
    <link href="/2024/07/04/JVM%E8%B0%83%E4%BC%98/"/>
    <url>/2024/07/04/JVM%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<p>关于JVM调优记录</p><p>首先 ，线上问题主要是两类 ，CPU和内存问题 。</p><p>先从JVM的底层结构出发 ，再到相关工具的使用 发现问题 ，最后如何解决问题  。</p><p>今天遇到的是一个内存飙高的问题 。</p><p><strong>项目背景</strong></p><p>星火工厂，在长时间运行后，出现了服务器响应缓慢、最终导致系统崩溃的情况，初步怀疑是内存泄露导致的内存溢出（OutOfMemoryError）。</p><p><strong>问题分析过程</strong></p><ol><li><p>获取堆转储文件</p><ul><li>在系统的 JVM 启动参数中添加 <code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/dump</code>，这样当系统再次出现内存溢出时，就可以在指定路径下获取堆转储文件。经过一段时间的观察，成功获取到了堆转储文件。</li></ul></li><li><p>使用 MAT 工具分析堆转储文件</p><ul><li><strong>查看直方图（Histogram）视图</strong>：使用 MAT 打开堆转储文件后，首先查看直方图视图。发现 <code>com.xinghuo.factory.entity.ProductRecord</code>对象（产品记录实体类）的数量异常庞大，占用了相当大的内存空间。这表明产品记录相关的操作可能存在问题。</li><li><strong>分析引用链（Reference Chain）</strong>：右键点击 <code>ProductRecord</code>对象，选择 “List objects -&gt; with incoming references” 来查看引用链。发现这些 <code>ProductRecord</code>对象被一个名为 <code>ProductRecordCache</code>的缓存类大量引用。这个缓存类是开发团队为了提高产品记录查询效率而自定义的一个本地缓存。</li><li><strong>深入研究缓存类（Cache Class）</strong>：进一步查看 <code>ProductRecordCache</code>类的内部结构，发现它是一个简单的 <code>HashMap</code>实现的缓存，用于存储从数据库查询出来的产品记录。但是，在系统的业务逻辑中，每次有新的产品记录生成或者更新时，都会将新的记录添加到这个缓存中，而没有对缓存中的旧记录进行清理或者过期处理。这就导致了随着时间的推移和生产活动的持续进行，缓存中的 <code>ProductRecord</code>对象越来越多，最终耗尽内存。</li></ul><p><strong>有一个缓存类；大量查看 <code>ProductRecordCache</code>类的内部结构，发现它是一个简单的 <code>HashMap</code>实现的缓存，用于存储从数据库查询出来的产品记录。但是，在系统的业务逻辑中，每次有新的产品记录生成或者更新时，都会将新的记录添加到这个缓存中，而没有对缓存中的旧记录进行清理或者过期处理。这就导致了随着时间的推移和生产活动的持续进行，缓存中的 <code>ProductRecord</code>对象越来越多，最终耗尽内存。没有清理</strong></p></li></ol><p><strong>解决方案</strong></p><ol><li>优化缓存策略<ul><li>为 <code>ProductRecordCache</code>添加了一个定时清理机制。根据业务需求，设置每隔 24 小时清理一次缓存中超过一周未被访问的 <code>ProductRecord</code>对象。<br>设置缓存过期时间</li><li>在产品记录更新或者删除的业务逻辑中，同时更新缓存中的对应记录，确保缓存数据的准确性和及时性。</li></ul></li><li>内存监控与预警<ul><li>在系统中添加了内存监控模块，实时监测 JVM 内存使用情况。当内存使用率达到一定阈值（如 80%）时，通过邮件或者系统消息的方式通知开发人员和运维人员，以便及时采取措施，避免系统崩溃。</li></ul></li></ol><p>经过以上优化和改进后，星火工厂的生产管理系统在长时间运行后不再出现内存溢出问题，服务器响应速度也恢复正常，有效保障了工厂生产管理活动的顺利进行。</p><p>相关扩展：</p><p>性能监控的命令行工具：</p><p>top</p><p>vmstat </p><p>iostat</p><p>nestat</p><p>监控系统整体的资源使用情况 ，比如说内存、cpu ，io使用情况 ，网络使用情况 。</p>]]></content>
    
    
    
    <tags>
      
      <tag>实战经验记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日算法-4</title>
    <link href="/2024/07/03/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-4/"/>
    <url>/2024/07/03/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-4/</url>
    
    <content type="html"><![CDATA[<p>算法</p><p>贪心算法：学会寻找局部最优，以实现全局最优</p><p>452.用最少的箭引爆气球</p><p>解题：对于气球所处区间进行排序，然后判断重合的气球，每次都击中重合最多的，更新左右边界计算重合的气球数。最后整体最优解</p><p>406.根据身高重建队列</p><p>解题：难点是如何处理二维的数据；</p><p>解决方法：先对身高进行排序，然后排后面的数值，只要把身高小的插在前面就不影响身高高的后面的数值</p><p>860.柠檬水找零</p><p>解题：三种情况，第三种主要是先给出10元的和全给5元</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目笔记-2</title>
    <link href="/2024/07/03/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-2/"/>
    <url>/2024/07/03/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-2/</url>
    
    <content type="html"><![CDATA[<p><strong>7月3日</strong></p><p>我认为我现在的开发方法是不对的。我是要在开发中发现问题，不断学习，而不是一直迷迷糊糊的，你需要清楚自己需要知道什么。</p><p>1、业务开发的流程</p><p><strong>2、redis如何使用</strong></p><p>3、springboot各种注解</p><p>4、Java开发的代码的逻辑框架。</p><p>实现功能：</p><p><strong>登录拦截器优化</strong></p><p>：获取token</p><p>查询redis</p><p>3.保存到ThreadLocal</p><p>4.刷新</p><p>5.放行</p><p>只要用户一直访问，就不刷新：分类拦截</p><p>无需登录就可查看的</p><p>再加一个拦截器，拦截一切，仅仅是刷新</p><p><strong>第二次：需要登陆的</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目笔记-1</title>
    <link href="/2024/07/03/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-1/"/>
    <url>/2024/07/03/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0-1-1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>项目笔记</title>
    <link href="/2024/07/02/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/07/02/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="项目笔记"><a href="#项目笔记" class="headerlink" title="项目笔记"></a>项目笔记</h1><p>黑马点评</p><p>短信登录</p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日算法-3</title>
    <link href="/2024/07/02/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-3/"/>
    <url>/2024/07/02/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-3/</url>
    
    <content type="html"><![CDATA[<h1 id="今日算法-2"><a href="#今日算法-2" class="headerlink" title="今日算法-2"></a>今日算法-2</h1><p>跳跃游戏</p><p>利用贪心算法：</p><p>如何理解贪心算法</p><p>局部最优解求得整体</p><p>想法1：最小；极限假设，不行</p><p>想法2：最大；可行只要求得最大覆盖范围大于数组的长度即可，</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日算法-2</title>
    <link href="/2024/07/02/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-2/"/>
    <url>/2024/07/02/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-2/</url>
    
    <content type="html"><![CDATA[<h1 id="今日算法-2"><a href="#今日算法-2" class="headerlink" title="今日算法-2"></a>今日算法-2</h1><p>跳跃游戏</p><p>利用贪心算法：</p><p>如何理解贪心算法</p><p>局部最优解求得整体</p><p>想法1：最小；极限假设，不行</p><p>想法2：最大；可行只要求得最大覆盖范围大于数组的长度即可，</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日算法-1</title>
    <link href="/2024/07/02/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-1/"/>
    <url>/2024/07/02/%E4%BB%8A%E6%97%A5%E7%AE%97%E6%B3%95-1/</url>
    
    <content type="html"><![CDATA[<p>LRU算法实践</p><p>LRU</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
